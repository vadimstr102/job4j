## Servlet

[1. Что такое сервлет?](#1-Что-такое-сервлет)

[2. Какова структура веб-проекта?](#2-Какова-структура-веб-проекта)

[3. Что такое контейнер сервлетов?](#3-Что-такое-контейнер-сервлетов)

[4. Каковы задачи, функциональность контейнера сервлетов?](#4-Каковы-задачи-функциональность-контейнера-сервлетов)

[5. Что вы знаете о сервлет фильтрах?](#5-Что-вы-знаете-о-сервлет-фильтрах)

[6. Зачем нужны слушатели в сервлетах?](#6-Зачем-нужны-слушатели-в-сервлетах)

[7. Когда вы будете использовать фильтры сервлетов, а когда слушатели?](#7-Когда-вы-будете-использовать-фильтры-сервлетов-а-когда-слушатели)

[8. Как обработать исключения, выброшенные другим сервлетом в приложении?](#8-Как-обработать-исключения-выброшенные-другим-сервлетом-в-приложении)

[9. Что такое дескриптор развертывания?](#9-Что-такое-дескриптор-развертывания)

[10. Как реализовать запуск сервлета с запуском приложения?](#10-Как-реализовать-запуск-сервлета-с-запуском-приложения)

[11. Что представляет собой объект ServletConfig?](#11-Что-представляет-собой-объект-ServletConfig)

[12. Что представляет собой объект ServletContext?](#12-Что-представляет-собой-объект-ServletContext)

[13. В чем отличия ServletContext и ServletConfig?](#13-В-чем-отличия-ServletContext-и-ServletConfig)

[14. Что такое Request Dispatcher?](#14-Что-такое-Request-Dispatcher)

[15. Как можно создать блокировку (deadlock) в сервлете?](#15-Как-можно-создать-блокировку-(deadlock)-в-сервлете)

[16. Как получить адрес сервлета на сервере?](#16-Как-получить-адрес-сервлета-на-сервере)

[17. Как получить информацию о сервере из сервлета?](#17-Как-получить-информацию-о-сервере-из-сервлета)

[18. Как получить ip адрес клиента на сервере?](#18-Как-получить-ip-адрес-клиента-на-сервере)

[19. Что вы знаете о классах обертках (wrapper) для сервлетов?](#19-Что-вы-знаете-о-классах-обертках-(wrapper)-для-сервлетов)

[20. Каков жизненный цикл сервлета и когда какие методы вызываются?](#20-Каков-жизненный-цикл-сервлета-и-когда-какие-методы-вызываются)

[21. Какие методы необходимо определить при создании сервлетов?](#21-Какие-методы-необходимо-определить-при-создании-сервлетов)

[22. В каком случае вы будете переопределять метод service()?](#22-В-каком-случае-вы-будете-переопределять-метод-service())

[23. Есть ли смысл определить конструктор для сервлета, как лучше инициализировать данные?](#23-Есть-ли-смысл-определить-конструктор-для-сервлета-как-лучше-инициализировать-данные)

[24. В чем отличия GenericServlet и HttpServlet?](#24-В-чем-отличия-GenericServlet-и-HttpServlet)

[25. Как вызвать из сервлета другой сервлет этого же и другого приложения?](#25-Как-вызвать-из-сервлета-другой-сервлет-этого-же-и-другого-приложения)

[26. Что вы знаете и в чем отличия методов forward() и sendRedirect()?](#26-Что-вы-знаете-и-в-чем-отличия-методов-forward()-и-sendRedirect())

[27. Стоит ли волноваться о “многопоточной безопасности” работая с сервлетами?](#27-Стоит-ли-волноваться-о-“многопоточной-безопасности”-работая-с-сервлетами)

[28. В чем отличие между веб сервером и сервером приложений?](#28-В-чем-отличие-между-веб-сервером-и-сервером-приложений)

[29. Какой метод HTTP не является неизменяемым?](#29-Какой-метод-HTTP-не-является-неизменяемым)

[30. Почему HttpServlet класс объявлен как абстрактный?](#30-Почему-HttpServlet-класс-объявлен-как-абстрактный)

[31. В чем разница между методами GET и POST?](#31-В-чем-разница-между-методами-GET-и-POST)

[32. Что такое MIME-тип?](#32-Что-такое-MIME-тип)

[33. Назовите преимущества Servlet над CGI?](#33-Назовите-преимущества-Servlet-над-CGI)

[34. Каковы наиболее распространенные задачи выполняются в Servlet контейнере?](#34-Каковы-наиболее-распространенные-задачи-выполняются-в-Servlet-контейнере)

[35. В чем разница между PrintWriter и ServletOutputStream?](#35-В-чем-разница-между-PrintWriter-и-ServletOutputStream)

[36. Можем ли мы получить PrintWriter и ServletOutputStream одновременно в сервлете?](#36-Можем-ли-мы-получить-PrintWriter-и-ServletOutputStream-одновременно-в-сервлете)

[37. Расскажите о интерфейсе SingleThreadModel.](#37-Расскажите-о-интерфейсе-SingleThreadModel)

[38. Какие существуют атрибуты у сервлетов и какая сфера их применения?](#38-Какие-существуют-атрибуты-у-сервлетов-и-какая-сфера-их-применения)

[39. Почему необходимо переопределить только init() метод без аргументов?](#39-Почему-необходимо-переопределить-только-init()-метод-без-аргументов)

[40. Что означает URL encoding? Зачем нужны методы java.net.URLEncoder.encode() и decode()?](#40-Что-означает-URL-encoding-Зачем-нужны-методы-javanetURLEncoderencode()-и-decode())

[41. Зачем нужны и чем отличаются методы encodeUrl() и encodeRedirectUrl()?](#41-Зачем-нужны-и-чем-отличаются-методы-encodeUrl()-и-encodeRedirectUrl())

[42. Какие различные методы управления сессией в сервлетах вы знаете?](#42-Какие-различные-методы-управления-сессией-в-сервлетах-вы-знаете)

[43. Что означает URL Rewriting?](#43-Что-означает-URL-Rewriting)

[44. Как применяются Cookies в сервлетах?](#44-Как-применяются-Cookies-в-сервлетах)

[45. Как уведомить объект в сессии, что сессия недействительна или закончилась?](#45-Как-уведомить-объект-в-сессии-что-сессия-недействительна-или-закончилась)

[46. Какой существует эффективный способ удостоверится, что все сервлеты доступны только для пользователя с валидной сессией?](#46-Какой-существует-эффективный-способ-удостоверится-что-все-сервлеты-доступны-только-для-пользователя-с-валидной-сессией)

[47. Как мы можем обеспечить transport layer security для нашего веб приложения?](#47-Как-мы-можем-обеспечить-transport-layer-security-для-нашего-веб-приложения)

[48. Как организовать подключение к базе данных и обеспечить логирование log4j в сервлете?](#48-Как-организовать-подключение-к-базе-данных-и-обеспечить-логирование-log4j-в-сервлете)

[49. Какие важные особенности существуют в Servlet 3?](#49-Какие-важные-особенности-существуют-в-Servlet-3)

[50. Каковы различные способы аутентификации сервлета?](#50-Каковы-различные-способы-аутентификации-сервлета)

[51. Написать сервлет, реализующий загрузку файла на сервер?](#51-Написать-сервлет-реализующий-загрузку-файла-на-сервер)

[52. ](#52-)

## 1. Что такое сервлет?

Сервлет является интерфейсом Java, реализация которого расширяет функциональные возможности сервера. 
Сервлет взаимодействует с клиентами посредством принципа запрос-ответ.
Хотя сервлеты могут обслуживать любые запросы, они обычно используются для расширения веб-серверов. 
Для таких приложений технология `Java Servlet` определяет HTTP-специфичные сервлет классы. 
Пакеты `javax.servlet` и `javax.servlet.http` обеспечивают интерфейсы и классы для создания сервлетов.

Основные методы сервлета:

+ `public void init(ServletConfig config) throws ServletException` запускается сразу после загрузки сервлета в память;
+ `public ServletConfig getServletConfig()` возвращает ссылку на объект, 
который предоставляет доступ к информации о конфигурации сервлета;
+ `public String getServletInfo()` возвращает строку, содержащую информацию о сервлете, например: автор и версия сервлета;
+ `public void service(ServletRequest request, ServletResponse response) throws ServletException, 
java.io.IOException` вызывается для обработки каждого запроса;
+ `public void destroy()` выполняется перед выгрузкой сервлета из памяти.

Развернуто:

Приложение Java, запускаемое и выполняемое в контейнере сервера приложений. Клиент общается с таким приложением посредством 
веб-браузера. Никаких дополнительных приложений на стороне клиента устанавливать не требуется. Сервлеты поддерживаются 
виртуальной машиной JVM, что предотвращает утечки памяти и обеспечивает функционирование garbage collection.
Каждому клиенту сервлет выделяет независимый поток выполнения. Клиент посылает приложению HTTP-запрос, сервлет генерирует 
ответ и возвращает его клиенту в виде html-документа.

Сервлет:
+ компонент приложений Java Enterprise Edition;
+ загружается веб-сервером в контейнер;
+ выполняется на стороне сервера;
+ обрабатывает клиентские запросы;
+ динамически генерирует ответы на запросы;
+ находится в состоянии ожидания, если запросы отсутствуют;
+ принимает запросы от других сервлетов (Servlet chaining);
+ поддерживает соединения с ресурсами.

Наибольшее распространение получили сервлеты, обрабатывающие клиентские запросы по протоколу HTTP. Технология сервлетов 
является оболочкой протокола HTTP и поддерживает его как транспорт передачи данных от клиента серверу и обратно. 
Контейнер сервлетов поддерживает также протокол HTTPS (HTTP и SSL) для защищаемых запросов.

Сервлеты в промышленном программировании используются для:
+ приема входящих данных от клиента;
+ взаимодействия с бизнес-логикой системы;
+ динамической генерации ответа клиенту.

Все сервлеты реализуют общий интерфейс Servlet из пакета javax.servlet. Для обработки HTTP-запросов в web можно 
воспользоваться в качестве базового класса абстрактным классом HttpServlet из пакета javax.servlet.http.

Java методы программирования. 2013 И.Н. Блинов, В.С. Романчик. c 456

https://docs.oracle.com/javaee/7/api/javax/servlet/Servlet.html

https://docs.oracle.com/javaee/7/tutorial/servlets001.htm#BNAFE

[к оглавлению](#Servlet)

## 2. Какова структура веб проекта?

| Path | Description |
| --- | --- |
| src/main/java| Application/Library sources |
| src/main/resources| Application/Library resources |
| src/main/filters| Resource filter files |
| src/main/webapp| Web application sources |
| src/test/java| Test sources |
| src/test/resources| Test resources |
| src/test/filters| Test resource filter files |
| src/it| Integration Tests (primarily for plugins) |
| src/assembly| Assembly descriptors |
| src/site| Site |
| LICENSE.txt| Project’s license |
| NOTICE.txt| Notices and attributions required by libraries that the project depends on |
| README.txt| Project’s readme 

http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html

[к оглавлению](#Servlet)

## 3. Что такое контейнер сервлетов?

**Контейнер сервлетов** — программа, представляющая собой сервер, который занимается системной поддержкой сервлетов 
и обеспечивает их жизненный цикл в соответствии с правилами, определёнными в спецификациях.

Известные реализации: 
+ Apache Tomcat
+ Jetty
+ JBoss
+ WildFly
+ GlassFish
+ IBM WebSphere
+ Oracle Weblogic

[к оглавлению](#Servlet)

## 4. Каковы задачи, функциональность контейнера сервлетов?

Контейнер сервлетов может работать как полноценный самостоятельный веб-сервер, быть поставщиком страниц для другого 
веб-сервера, например Apache, или интегрироваться в Java EE сервер приложений.

Обеспечивает обмен данными между сервлетом и клиентами, берёт на себя выполнение таких функций, 
как создание программной среды для функционирующего сервлета, идентификацию и авторизацию клиентов, организацию сессии 
для каждого из них.

[к оглавлению](#Servlet)

## 5. Что вы знаете о сервлет фильтрах?

**Сервлетный фильтр** - это Java-код, пригодный для повторного использования и позволяющий преобразовать содержание 
HTTP-запросов, HTTP-ответов и информацию, содержащуюся в заголовках HTML. Сервлетный фильтр занимается предварительной 
обработкой запроса, прежде чем тот попадает в сервлет, и/или последующей обработкой ответа, исходящего из сервлета.

Сервлетные фильтры могут:

+ перехватывать инициацию сервлета прежде, чем сервлет будет инициирован;
+ определить содержание запроса прежде, чем сервлет будет инициирован;
+ модифицировать заголовки и данные запроса, в которые упаковывается поступающий запрос;
+ модифицировать заголовки и данные ответа, в которые упаковывается получаемый ответ;
+ перехватывать инициацию сервлета после обращения к сервлету.

Сервлетный фильтр может быть конфигурирован так, что он будет работать с одним сервлетом или группой сервлетов. 
Основой для формирования фильтров служит интерфейс `javax.servlet.Filter`, который реализует три метода:

+ `void init(FilterConfig config) throws ServletException`;
+ `void destroy()`;
+ `void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException`;

Метод `init()` вызывается прежде, чем фильтр начинает работать,и настраивает конфигурационный объект фильтра. 
Метод `doFilter()` выполняет непосредственно работу фильтра. Таким образом, сервер вызывает `init()` один раз, 
чтобы запустить фильтр в работу, а затем вызывает `doFilter()` столько раз, сколько запросов будет сделано 
непосредственно к данному фильтру. После того, как фильтр заканчивает свою работу, вызывается метод `destroy()`.

Интерфейс `FilterConfig` содержит метод для получения имени фильтра, его параметров инициации и контекста активного 
в данный момент сервлета. С помощью своего метода `doFilter()` каждый фильтр получает текущий запрос `request` и 
ответ `response`, а также `FilterChain`, содержащий список фильтров, предназначенных для обработки. 
В `doFilter()` фильтр может делать с запросом и ответом всё, что ему захочется - собирать данные или упаковывать объекты 
для придания им нового поведения. Затем фильтр вызывает `chain.doFilter()`, чтобы передать управление следующему фильтру. 
После возвращения этого вызова фильтр может по окончании работы своего метода `doFilter()` выполнить дополнительную работу 
над полученным ответом. К примеру, сохранить регистрационную информацию об этом ответе.

После того, как класс-фильтр откомпилирован, его необходимо установить в контейнер и _«приписать» (map)_ к одному или 
нескольким сервлетам. Объявление и подключение фильтра отмечается в дескрипторе развёртывания `web.xml` внутри 
элементов <filter> и <filter-mapping>. 
Для подключение фильтра к сервлету необходимо использовать вложенные элементы <filter-name> и <servlet-name>.

> Объявление класс-фильтра `FilterConnect` с именем `FilterName`:

```xml
  <filter>
        <filter-name>FilterName</filter-name>
        <filter-class>FilterConnect</filter-class>
        <init-param>
                <!--- фильтр имеет параметр инициализации `active`, которому присваивается значение `true`. -->
                <param-name>active</param-name>
                <param-value>true</param-true>
        </init-param>
  </filter>
```

> Подключение фильтра `FilterName` к сервлету `ServletName`:

```xml
  <filter-mapping>
        <filter-name>FilterName</filter-name>
        <servlet-name>ServletName</servlet-name>
  </filter-mapping>
```
Для связи фильтра со страницами HTML или группой сервлетов необходимо использовать тег `<url-pattern>`:

> Подключение фильтра `FilterName` ко всем вызовам .html страниц

```xml
  <filter-mapping>
          <filter-name>FilterName</filter-name>
          <url-pattern>*.html</url-pattern>
  </filter-mapping>
```

Порядок, в котором контейнер строит цепочку фильтров для запроса определяется следующими правилами:

+ цепочка, определяемая `<url-pattern>`, выстраивается в том порядке, в котором встречаются соответствующие описания 
фильтров в `web.xml`;
+ последовательность сервлетов, определенных с помощью `<servlet-name>`, также выполняется в той последовательности, 
в какой эти элементы встречаются в дескрипторе развёртывания `web.xml`.

https://www.journaldev.com/1933/java-servlet-filter-example-tutorial

[к оглавлению](#Servlet)

## 6. Зачем нужны слушатели в сервлетах?

__Listener (слушатель)__ работает как триггер, выполняя определённые действия при наступлении какого-либо события 
в жизненном цикле сервлета.

Слушатели, разделённые по области видимости (scope):

+ _Request_:
    + `ServletRequestListener` используется для того, чтобы поймать момент создания и уничтожения запроса;
    + `ServletRequestAttributeListener` используется для прослушивании событий происходящих с атрибутами запроса.
+ _Context_:
    + `ServletContextListener` позволяет поймать момент, когда контекст инициализируется либо уничтожается;
    + `ServletContextAttributeListener` используется для прослушивании событий происходящих с атрибутами в контексте.
+ _Session_:
    + `HttpSessionListener` позволяет поймать момент создания и уничтожения сессии;
    + `HttpSessionAttributeListener` используется при прослушивании событий происходящих с атрибутами в сессии;
    + `HttpSessionActivationListener` используется в случае, если происходит миграция сессии между различными JVM в 
    распределённых приложениях;
    + `HttpSessionBindingListener` так же используется для прослушивания событий происходящих с атрибутами в сессии. 
    
    Разница между `HttpSessionAttributeListener` и `HttpSessionBindingListener` слушателями: 
    + `HttpSessionAttributeListener` декларируется в `web.xml`, экземпляр класса создается контейнером автоматически 
    в единственном числе и применяется ко всем сессиям; 
    + для `HttpSessionBindingListener` экземпляр класса должен быть создан и закреплён за определённой сессией «вручную», 
    количество экземпляров также регулируется самостоятельно.

Подключение слушателей:

```xml
<web-app>
    ...
    <listener>
        <listener-class>xyz.company.ExampleListener</listener-class>
    </listener>
    ...
</web-app>
```

`HttpSessionBindingListener` подключается в качестве атрибута непосредственно в сессию, т.е., чтобы его подключить необходимо:
+ создать экземпляр класса реализующего этот интерфейс;
+ положить созданный экземпляр в сессию при помощи `setAttribute(String, Object)`.

[к оглавлению](#Servlet)

## 7. Когда вы будете использовать фильтры сервлетов, а когда слушатели?

Следует использовать фильтры, если необходимо обрабатывать входящие или исходящие данные 
(например: для аутентификации, преобразования формата, компрессии, шифрования и т.д.), 
в случае, когда необходимо реагировать на события - лучше применять слушателей.

http://www.journaldev.com/1945/servlet-listener-example-servletcontextlistener-httpsessionlistener-and-servletrequestlistener

[к оглавлению](#Servlet)

## 8. Как обработать исключения, выброшенные другим сервлетом в приложении?

Когда приложение выбрасывет исключение контейнер сервлетов обрабатывает его и создаёт ответ в формате HTML.
(т.е. контейнер создаст HTTP response, т.к. браузер понимает только HTTP)
Это аналогично тому что происходит при кодах ошибок вроде 404, 403 и т.д.

В дополнении к этому существует возможность написания собственных сервлетов для обработки исключений и ошибок 
с указанием их в дескрипторе развертывания:

```xml
<error-page>
    <error-code>404</error-code>
    <location>/AppExceptionHandler</location>
</error-page>
<error-page>
    <exception-type>javax.servlet.ServletException</exception-type>
    <location>/AppExceptionHandler</location>
</error-page>
```

Основная задача таких сервлетов - обработать ошибку/исключение и сформировать понятный HTTP ответ пользователю. 
Например, предоставить ссылку на главную страницу или же описание некоторых деталей об ошибке.

http://www.journaldev.com/1973/servlet-exception-and-error-handling-example-tutorial

[к оглавлению](#Servlet)

## 9. Что такое дескриптор развертывания?

**Дескриптор развертывания** — это конфигурационный файл артефакта, который будет развернут в контейнере сервлетов. 
В спецификации Java Platform, Enterprise Edition дескриптор развертывания описывает то, как компонент, модуль или 
приложение (такое, как веб-приложение или приложение предприятия) должно быть развернуто.

Этот конфигурационный файл указывает параметры развертывания для модуля или приложения с определенными настройками, 
параметры безопасности и описывает конкретные требования к конфигурации. Для синтаксиса файлов дескриптора 
развертывания используется язык XML.

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<web-app xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
    version="2.4">
    
    <display-name>Display name.</display-name>
    <description>Description text.</description>
    
    <servlet>
        <servlet-name>ExampleServlet</servlet-name>
        <servlet-class>xyz.company.ExampleServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
        <init-param>
            <param-name>configuration</param-name>
            <param-value>default</param-value>
        </init-param>       
    </servlet>
    
    <servlet-mapping>
        <servlet-name>ExampleServlet</servlet-name>
        <url-pattern>/example</url-pattern>
    </servlet-mapping>
    
    <servlet>
        <servlet-name>ExampleJSP</servlet-name>
        <jsp-file>/sample/Example.jsp</jsp-file>
    </servlet>
    
    <context-param>
        <param-name>myParam</param-name>
        <param-value>the value</param-value>
    </context-param>
</web-app>
```

Для веб-приложений дескриптор развертывания должен называться `web.xml` и находиться в директории `WEB-INF`, в корне 
веб-приложения. Этот файл является стандартным дескриптором развертывания, определенным в спецификации. 
Также есть и другие типы дескрипторов, такие, как файл дескриптора развертывания `sun-web.xml`, содержащий специфичные 
для _Sun GlassFish Enterprise Server_ данные для развертывания именно для этого сервера приложений или 
файл `application.xml` в директории `META-INF` для приложений _J2EE_.

Настройка и описание web.xml в приложении с Spring и JSF
http://javastudy.ru/jsf-2/description-settings-web-xml-with-spring

[к оглавлению](#Servlet)

## 10. Как реализовать запуск сервлета с запуском приложения?

Контейнер сервлетов обычно загружает сервлет по первому запросу клиента.

Если необходимо загрузить сервлет прямо на старте приложения (например если загрузка сервлета происходит длительное время) 
следует использовать элемент `<load-on-startup>` в дескрипторе или аннотацию `@loadOnStartup` в коде сервлета, 
что будет указывать на необходимость загрузки сервлета при запуске.

Значение должно быть целочисленное `int`. Если значение отрицательное, то сервлет будет загружен при запросе клиента. 
В противном случае (0 и далее) - загрузится на старте приложения. 
Чем число меньше, тем раньше в очереди на загрузку окажется сервлет.

```xml
<servlet>
    <servlet-name>ExampleServlet</servlet-name>
    <servlet-class>xyz.company.ExampleServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
```

[к оглавлению](#Servlet)

## 11. Что представляет собой объект ServletConfig?

Интерфейс `javax.servlet.ServletConfig` используется для передачи сервлету конфигурационной информации. 
Каждый сервлет имеет свой собственный экземпляр объекта `ServletConfig`, создаваемый контейнером сервлетов.

Для установки параметров конфигурации используются параметры `init-param` в `web.xml`:

```xml
<servlet>
    <servlet-name>ExampleServlet</servlet-name>
    <servlet-class>xyz.company.ExampleServlet</servlet-class>
    <init-param>
        <param-name>exampleParameter</param-name>
        <param-value>parameterValue</param-value>
    </init-param>
</servlet>
```

или аннотации `@WebInitParam`:

```java
@WebServlet(
    urlPatterns = "/example",
    initParams = {
        @WebInitParam(name = "exampleParameter", value = "parameterValue")
    }
)
public class ExampleServlet extends HttpServlet {
    //...
}
```

Для получения `ServletConfig` сервлета используется метод `getServletConfig()`.

[к оглавлению](#Servlet)

## 12. Что представляет собой объект ServletContext?

Уникальный (в рамках веб-приложения) объект `ServletContext` реализует интерфейс `javax.servlet.ServletContext` и 
предоставляет сервлетам доступ к параметрам этого веб-приложения. Для предоставления доступа используется элемент 
`<context-param>` в `web.xml`:

```xml
<web-app>
    ...
    <context-param>
        <param-name>exampleParameter</param-name>
        <param-value>parameterValue</param-value>
    </context-param>
    ...
</web-app>
```

Объект `ServletContext` можно получить с помощью метода `getServletContext()` у интерфейса `ServletConfig`. 
Контейнеры сервлетов так же могут предоставлять контекстные объекты, уникальные для группы сервлетов. 
Каждая из групп будет связана со своим набором URL-путей хоста. В спецификации Servlet 3 `ServletContext` был расширен 
и теперь предоставляет возможности программного добавления слушателей и фильтров в приложение. 

Так же у этого интерфейса имеется множество полезных методов таких как `getServerInfo()`, `getMimeType()`, 
`getResourceAsStream()` и т.д.

[к оглавлению](#Servlet)

## 13. В чем отличия ServletContext и ServletConfig?

+ `ServletConfig` уникален для сервлета, а `ServletContext` - для приложения;
+ `ServletConfig` используется для предоставления параметров инициализации конкретному сервлету, 
а `ServletContext` для предоставления параметров инициализации для всех сервлетов приложения;
+ для `ServletConfig` возможности модифицировать атрибуты отсутствуют, атрибуты в объекте `ServletContext` можно изменять.

[к оглавлению](#Servlet)

## 14. Что такое Request Dispatcher?

Интерфейс `RequestDispatcher` используется для передачи запроса другому ресурсу, при этом существует возможность 
добавления данных полученных из этого ресурса к собственному ответу сервлета. 
Так же этот интерфейс используется для внутренней коммуникации между сервлетами в одном контексте.

В интерфейса реализовано два метода:

+ `void forward(ServletRequest var1, ServletResponse var2)` — передает запрос из сервлета к другому 
ресурсу (сервлету, JSP или HTML файлу) на сервере.
+ `void include(ServletRequest var1, ServletResponse var2)` — включает контент ресурса (сервлет, JSP или HTML страница) 
в ответ.

Доступ к интерфейсу можно получить с помощью метода 
интерфейса `ServletContext` - `RequestDispatcher getRequestDispatcher(String path)`, 
где путь начинающийся с `/`, интерпретируется относительно текущего корневого пути контекста.

[к оглавлению](#Servlet)

## 15. Как можно создать блокировку (deadlock) в сервлете?

Дедлок можно получить реализовав зацикленный вызов метода, например, вызвав метод `doPost()` в методе `doGet()` 
и метод `doGet()` в методе `doPost()`.

[к оглавлению](#Servlet)

## 16. Как получить адрес сервлета на сервере?

Реальный путь к расположению сервлета на сервере можно получить из объекта `ServletContext`: 

`getServletContext().getRealPath(request.getServletPath())`.

[к оглавлению](#Servlet)

## 17. Как получить информацию о сервере из сервлета?

Информацию о сервере можно получить из объекта `ServletContext` с помощью метода `getServerInfo()`: 

`getServletContext().getServerInfo()`.

[к оглавлению](#Servlet)

## 18. Как получить ip адрес клиента на сервере?

`request.getRemoteAddr()` используется для получения в сервлете IP адреса клиента на сервере.

[к оглавлению](#Servlet)

## 19. Что вы знаете о классах обертках (wrapper) для сервлетов?

Собственные обработчики `ServletRequest` и `ServletResponse` можно реализовать добавив новые или переопределив 
существующие методы у классов-обёрток `ServletRequestWrapper` (`HttpServletRequestWrapper`) и 
`ServletResponseWrapper` (`HttpServletRequestWrapper`).

Данные классы-обертки помогают разработчикам реализовывать собственные реализации типов `request` и `response` сервлета. 
Можно расширить эти классы и переопределить только необходимые методы для реализации собственных типов объектов ответов и запросов. 
Эти классы не используются в стандартном программировании сервлетов.

[к оглавлению](#Servlet)

## 20. Каков жизненный цикл сервлета и когда какие методы вызываются?

Контейнер сервлетов управляет четырьмя фазами жизненного цикла сервлета:

+ **Загрузка класса сервлета** — когда контейнер получает запрос для сервлета, то происходит загрузка класса сервлета в 
память и вызов его конструктора без параметров.
+ **Инициализация класса сервлета** — после того как класс загружен контейнер инициализирует объект `ServletConfig` для этого 
сервлета и внедряет его через `init()` метод. Это и есть место где сервлет класс преобразуется из обычного класса в сервлет.
+ **Обработка запросов** — после инициализации сервлет готов к обработке запросов. Для каждого запроса клиента сервлет 
контейнер порождает новый поток и вызывает метод `service()` путем передачи ссылки на объект ответы и запроса.
+ **Удаление из Service** - когда контейнер останавливается или останавливается приложение, то контейнер сервлетов 
уничтожает классы сервлетов путем вызова `destroy()` метода.

Таким образом, сервлет создаётся при первом обращении к нему и живёт на протяжении всего времени работы приложения 
(в отличии от объекты классов, которые уничтожаются сборщиком мусора после того как они уже не используются) и весь 
жизненный цикл сервлета можно описать как последовательность вызова методов:

+ `public void init(ServletConfig config)` – используется контейнером для инициализации сервлета. 
Вызывается один раз за время жизни сервлета.
+ `public void service(ServletRequest request, ServletResponse response)` – вызывается для каждого запроса. 
Метод не может быть вызван раньше выполнения `init()` метода.
+ `public void destroy()` – вызывается для уничтожения сервлета (один раз за время жизни сервлета).

https://docs.oracle.com/javaee/7/tutorial/servlets002.htm#BNAFI

[к оглавлению](#Servlet)

## 21. Какие методы необходимо определить при создании сервлетов?

Чтобы создать сервлет, необходимо описать его в дескрипторе развёртывания:

>Пример 1

```xml
<servlet-mapping> 
  <servlet-name>MyOwnDefaultServlet</servlet-name>
  <url-pattern>/myservlet/*</url-pattern>
</servlet-mapping>
 
<servlet>
  <servlet-name>HelloWorld2</servlet-name> 
  <servlet-class>examples.servlets.HelloWorld2</servlet-class>
   <init-param>
    <param-name>greeting</param-name> 
    <param-value>Welcome</param-value> 
  </init-param>
   <init-param>
    <param-name>person</param-name> 
    <param-value>WebLogic Developer</param-value> 
  </init-param>
</servlet>
```

>Пример 2

```xml
<servlet-mapping>
    <servlet-name>ExampleServlet</servlet-name>
    <url-pattern>/example</url-pattern>
</servlet-mapping>

<servlet>
    <servlet-name>ExampleServlet</servlet-name>
    <servlet-class>xyz.company.ExampleServlet</servlet-class>
    <init-param>
        <param-name>config</param-name>
        <param-value>default</param-value>
    </init-param>       
</servlet>
```

Затем создать класс сервлета `examples.servlets.HelloWorld2` или для примера 2 `xyz.company.ExampleServlet`
путём наследования от `HttpServlet` и реализовать логику его работы 
в методе `service()` или методах `doGet()`/`doPost()` (или первый или вторые).

[к оглавлению](#Servlet)

## 22. В каком случае вы будете переопределять метод service()?

Метод `service()` переопределяется, когда необходимо, чтобы сервлет обрабатывал все запросы (и `GET`, и `POST`) в одном методе.

Когда контейнер сервлетов получает запрос клиента, то происходит вызов метода `service()`, 
который в зависимости от поступившего запроса вызывает или метод `doGet()` или метод `doPost()`.

[к оглавлению](#Servlet)

## 23. Есть ли смысл определить конструктор для сервлета, как лучше инициализировать данные?

Такая возможность есть, но считается бессмысленной. 
Инициализировать данные лучше не в конструкторе, а переопределив метод `init()`, 
в котором имеется возможность доступа к параметрам инициализации сервлета через использование объекта `ServletConfig`.

[к оглавлению](#Servlet)

## 24. В чем отличия GenericServlet и HttpServlet?

Абстрактный класс `GenericServlet` — независимая от используемого протокола реализация интерфейса `Servlet`, 
а абстрактный класс `HttpServlet` в свою очередь расширяет `GenericServlet` для протокола HTTP.

Следует отметить, что HttpServlet extends GenericServlet.

https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html

https://docs.oracle.com/javaee/7/api/javax/servlet/GenericServlet.html

[к оглавлению](#Servlet)

## 25. Как вызвать из сервлета другой сервлет этого же и другого приложения?

Для вызова сервлета из того же приложения необходимо использовать механизм внутренней коммуникации сервлетов 
(_inter-servlet communication mechanisms_) через вызовы методов `RequestDispatcher` - `forward()` и `include()` 
для доступа к дополнительным атрибутам в запросе для использования в другом сервлете:
 
+ `forward()` - передаёт выполнение запроса в другой сервлет;
+ `include()` - предоставляет возможность включить результат работы другого сервлета в возвращаемый ответ.

Если необходимо вызывать сервлет принадлежащий другому приложению, то использовать `RequestDispatcher` уже не получится, 
т.к. он определен только для текущего приложения. Для подобных целей необходимо использовать 
метод `ServletResponse` - `sendRedirect()` которому предоставляется полный URL из другого сервлета. 
Для передачи данных между сервлетами можно использовать `cookies`. 
(т.е. можно использовать `cookies` как часть ответа сервлета, а потом использовать их в нашем сервлете)

[к оглавлению](#Servlet)

## 26. Что вы знаете и в чем отличия методов forward() и sendRedirect()?

+ `RequestDispatcher forward()` используется для проброски того же самого запроса к другому ресурсу, 
в то время как `ServletResponse sendRedirect()` это двухшаговый метод. 
Во втором методе веб приложение возвращает ответ клиенту с `status code 302 (redirect)` с ссылкой для отправки запроса. 
Запрос посылает полностью новый запрос.
+ `forward()` обрабатывается внутри контейнера, а `sendRedirect()` обрабатывается браузером.
+ Необходимо использовать `forward()` для организации доступа внутри одного и того же приложения, 
т.к. он быстрее `sendRedirect()`, которому требуется дополнительная сетевая работа.
+ В методе `forward()` браузер не знает о фактически обрабатываемом ресурсе и URL в строке остается прежним. 
В `sendRedirect()` методе URL адрес изменяется на пробрасываемый ресурс.
+ В методе `forward()` нельзя использовать для внедрения сервлета в другой контекст. 
Для этого можно использовать только `sendRedirect()`.

| __`forward()`__ | __`sendRedirect()`__ |
| --- | --- |
| Выполняется на стороне сервера | Выполняется на стороне клиента |
| Запрос перенаправляется на другой ресурс в пределах того же сервера | Клиенту возвращается ответ `302 (redirect)` и запрос перенаправляется на другой сервер |
| Не зависит от протокола клиентского запроса клиента, так как обеспечивается контейнером сервлетов | Может использоваться только с клиентами HTTP |
| Нельзя применять для внедрения сервлета в другой контекст | Разрешается применять для внедрения сервлета в другой контекст |
| Клиент не знает о фактически обрабатываемом ресурсе и URL в строке остается прежним | URL адрес изменяется на адрес нового ресурса |
| Выполняется быстрее метода `sendRedirect()` | Медленнее `forward()` т.к. требует создания нового запроса |
| Определён в интерфейсе `RequestDispatcher` | Определён в интерфейсе `HttpServletResponse` |

[к оглавлению](#Servlet)

## 27. Стоит ли волноваться о “многопоточной безопасности” работая с сервлетами?

Методы `init()` и `destroy()` вызываются один раз за жизненный цикл сервлета — поэтому по поводу них беспокоиться не стоит. 

Методы `doGet()`, `doPost()`, `service()` вызываются на каждый запрос клиента и т.к. сервлеты используют многопоточность, 
то здесь задумываться о потокобезопасной работе обязательно. 

При этом правила использования многопоточности остаются теми же: 
+ локальные переменные этих методов будут созданы отдельно для каждой нити. 
+ при использовании глобальных разделяемых ресурсов необходимо использовать синхронизацию или другие приёмы 
многопоточного программирования.

[к оглавлению](#Servlet)

## 28. В чем отличие между веб сервером и сервером приложений?

**Веб сервер** необходим для обработки `HTTP request` от браузера клиента и ответа клиенту с помощью `HTTP response`. 
Веб сервер понимает язык HTTP и запускается по HTTP протоколу. 

Примером веб сервера может служить реализация от Apache - Tomcat.

**Сервер приложений** — это веб сервер с дополнительными возможностями, 
которые помогают разрабатывать корпоративные приложения.

Например, поддержка JavaBeans, JMS Messaging, Transaction Management и др.

[к оглавлению](#Servlet)

## 29. Какой метод HTTP не является неизменяемым?

+ HTTP метод называется неизменяемым, если он на один и тот же запрос всегда возвращает одинаковый результат. 
HTTP методы `GET`, `PUT`, `DELETE`, `HEAD` и `OPTIONS` являются неизменяемыми, поэтому необходимо реализовывать 
приложение так, чтобы эти методы возвращали одинаковый результат постоянно.

    Эти методы должны быть идемпотентными («idempotence») в том смысле, что повторное (более одного раза) выполнение
запросов с помощью этих методов будет иметь тот же эффект, что и однократное выполнение.

+ К изменяемым методам относится метод `POST`, который и используется для реализации чего-либо, что изменяется при каждом запросе.

К примеру, для доступа к статической HTML странице используется метод `GET`, т.к. он всегда возвращает одинаковый результат. 
При необходимости сохранять какую-либо информацию, например в базе данных, нужно использовать `POST` метод.
Неизменяемые методы так же известны как безопасные методы и нет необходимости заботиться о повторяющихся 
запросах от клиента для этих методов.

[к оглавлению](#Servlet)

## 30. Почему HttpServlet класс объявлен как абстрактный?

Класс `HTTPServlet` объявлен как абстрактный, т.к. он предоставляет лишь общую реализацию сервлета для HTTP протокола. 
Реализация ключевых методов `doGet()` и `doPost()`, содержащих основную бизнес-логику перекладывается на разработчика 
и по умолчанию возвращает `HTTP 405 Method Not Implemented error`.

[к оглавлению](#Servlet)

## 31. В чем разница между методами GET и POST?

+ `GET` передает данные серверу используя URL, тогда как `POST` передает данные, используя тело HTTP запроса. 
Длина URL ограничена 1024 символами, это и будет верхним ограничением для данных, 
которые можно отослать через `GET`. `POST` может отправлять гораздо большие объемы данных. 
Лимит устанавливается `web-server` и составляет обычно около 2 Mb.
+ Данные `GET` метода передаются в открытом виде, `POST` данные передаются в теле запроса и скрыты от пользователя.
Поэтому передача данных методом `POST` более безопасна, чем методом `GET`, т.к. секретные данные (например пароль) 
не отображаются напрямую в web-клиенте пользователя, в отличии от URL, который виден почти всегда. 
Иногда это преимущество становится недостатоком - вы не сможете послать данные за кого-то другого.
+ `GET`метод является неизменяемым, тогда как `POST` — изменяемый.
+ `GET` метод является HTTP методом по умолчанию, а `POST` метод необходимо указывать явно, чтобы отправить запрос.
+ `GET` метод используется гиперссылками на странице.

[к оглавлению](#Servlet)

## 32. Что такое MIME тип?

**MIME** (англ. Multipurpose Internet Mail Extensions — многоцелевые расширения интернет-почты) - это стандарт, 
описывающий передачу различных типов данных по электронной почте, а также, в общем случае, 
спецификация для кодирования информации и форматирования сообщений таким образом, чтобы их можно было пересылать по Интернету. 

`Content-Type response header` это и есть MIME тип.
 
Сервер посылает MIME тип клиенту для того, чтобы он понял какой тип данных пересылается. 
Это помогает верно отобразить полученные данные на клиенте. 

Наиболее часто используемые MIME типы: text/html, text/xml, application/xml и многие др.
В `ServletContext` существует метод `getMimeType()` для получения корректного MIME типа файла 
и дальнейшего использования этой информации для указания типа контента в ответе.

[к оглавлению](#Servlet)

## 33. Назовите преимущества Servlet над CGI?

Технология сервлетов была создана для преодоления недостатков Common Gateway Interface (общий интерфейс шлюза). 
Можно выделить следующие преимущества сервлетов над CGI:

+ **Быстродействие.** Сервлеты предоставляют лучшую производительность в условиях обработки запросов, 
лучшее использование памяти за счет использования преимущество многопоточности 
(на каждый запрос создается новая нить, что быстрее выделения памяти под новый объект для каждого запроса, как это происходит в CGI).
+ **Переносимость на различные платформы.** Сервлеты, платформа и система являются независимыми. 
Т.е. веб приложение написанное с использованием сервлетов может быть запущено в любом контейнере сервлетов, 
реализующим стандарт и в любой операционной системе.
+ **Надежность.** Использование сервлетов повышает надежность программы, 
т.к. контейнер сервлетов самостоятельно заботится о жизненном цикле сервлетов (а значит и за утечками памяти), 
безопасности и сборщике мусора.
+ Сервлеты относительно легки в изучении и поддержке, поэтому разработчику необходимо заботиться только о бизнес логике приложения, 
а не внутренней реализации веб технологий.

[к оглавлению](#Servlet)

## 34. Каковы наиболее распространенные задачи выполняются в Servlet контейнере?

+ **Поддержка обмена данными**. Контейнер сервлетов предоставляет легкий способ обмена данными между веб клиентом (браузером) и сервлетом. 
Благодаря контейнеру нет необходимости создавать слушателя сокета на сервере для отслеживания запросов от клиента, 
а так же разбирать запрос и генерировать ответ. 
Все эти важные и комплексные задачи решаются с помощью контейнера и разработчик может сосредоточиться на бизнес логике приложения.
+ **Управление жизненным циклом сервлетов и ресурсов**. Начиная от загрузки сервлета в память, инициализации, внедрения методов и заканчивая уничтожением сервлета. 
Контейнер так же предоставляет дополнительные утилиты, например JNDI, для управления пулом ресурсов.
+ **Поддержка многопоточности**. Контейнер самостоятельно создает новую нить для каждого запроса и предоставляет ей запрос и ответ для обработки. 
Таким образом сервлет не инициализируется заново для каждого запроса и тем самым сохраняет память и уменьшает время до обработки запроса.
+ **Поддержка JSP**. JSP классы не похожи на стандартные классы джавы, но контейнер сервлетов преобразует каждую JSP в сервлет и далее управляется контейнером как обычным сервлетом.
+ **Различные задачи**. Контейнер сервлетов управляет пулом ресурсов, памятью приложения, сборщиком мусора. Предоставляются возможности настройки безопасности и многое другое.

[к оглавлению](#Servlet)

## 35. В чем разница между PrintWriter и ServletOutputStream?

`PrintWriter` — это класс для работы с символьным потоком, а `ServletOutputStream` — класс для работы байтовым потоком. 

`PrintWriter` используется для записи информации на основе символов, вроде массива символов или строки в ответ, 
в то время как `ServletOutputStream` используется для записи в ответ массива байтов. 

Для получения экземпляра `ServletOutputStream` используется метод `ServletResponse` `getOutputStream()`, 
а для `PrintWriter` — метод `ServletResponse` `getWriter()`.

[к оглавлению](#Servlet)

## 36. Можем ли мы получить PrintWriter и ServletOutputStream одновременно в сервлете?

Мы не можем создать объекты этих классов в одном сервлете. 
При попытке одновременного вызова `getWriter()` и `getOutputStream()` будет выброшено 
исключение `java.lang.IllegalStateException` с сообщением, что уже был вызван другой метод.

[к оглавлению](#Servlet)

## 37. Расскажите о интерфейсе SingleThreadModel?

Интерфейс `SingleThreadModel` является маркерным - в нем не объявлен ни один метод, однако, если сервлет реализует 
этот интерфейс, то метод `service()` этого сервлета гарантированно не будет одновременно выполняться в двух потоках. 
Контейнер сервлетов либо синхронизирует обращения к единственному экземпляру, либо обеспечивает поддержку пула 
экземпляров и перенаправление запроса свободному сервлету.
Другими словами, контейнер гарантирует отсутствие конфликтов при одновременном обращении к переменным или методам 
экземпляра сервлета. 

Однако интерфейс `SingleThreadModel` не решает всех проблем потокобезопасности.
Т.к. существуют также и другие разделяемые ресурсы (например, атрибуты сессии или статические переменные), 
которые даже при использовании этого интерфейса, остаются всё так же доступны обработчикам запросов в других потоках. 

Т.о. пользы от использования этого интерфейса немного и в спецификации Servlet 2.4 он был объявлен `deprecated`.

[к оглавлению](#Servlet)

## 38. Какие существуют атрибуты у сервлетов и какая сфера их применения?

Атрибуты сервлетов используются для внутренней коммуникации сервлетов.

В веб-приложении существует возможность работы с атрибутами используя методы `setAttribute()`, `getAttribute()`, 
`removeAttribute()`, `getAttributeNames()`, которые предоставлены интерфейсами `ServletRequest`, `HttpSession` и 
`ServletContext` (для областей видимости _request scope_, _session scope_, _context scope_ соответственно).

[к оглавлению](#Servlet)

## 39. Почему необходимо переопределить только init() метод без аргументов?

Метод `init()` переопределяется, если необходимо инициализировать какие-то данные до того как сервлет начнет 
обрабатывать запросы. 

При переопределении метода `init(ServletConfig config)`, первым должен быть вызван метод `super(config)`, который 
обеспечит вызов метода `init(ServletConfig config)` суперкласса. 

`GenericServlet` предоставляет другой метод `init()` без параметров, который будет вызываться в конце метода `init(ServletConfig config)`.

Необходимо использовать переопределенный метод `init()` без параметров для инициализации данных во избежание 
каких-либо проблем, например ошибки, когда вызов `super()` не указан в переопределенном `init(ServletConfig config)`.

[к оглавлению](#Servlet)

## 40. Что означает URL encoding Зачем нужны методы javanetURLEncoderencode() и decode()?

__URL Encoding__ — процесс преобразования данных в форму CGI (Common Gateway Interface), не содержащую пробелов и 
нестандартных символов, которые заменяются в процессе кодирования на специальные escape-символы. 

В Java для кодирования строки используется метод `java.net.URLEncoder.encode(String str, String unicode)`. 
Обратная операция декодирования возможна через использование метода `java.net.URLDecoder.decode(String str, String unicode)`. 

Примеры работы метода:

> `Hello мир!` преобразовывается в `Hello%20%D0%BC%D0%B8%D1%80!`

> `Java for study .ru` преобразовается в `Java%20for%20study%20.ru`

[к оглавлению](#Servlet)

## 41. Зачем нужны и чем отличаются методы encodeUrl() и encodeRedirectUrl()?

`HttpServletResponse.encodeURL()` предоставляет способ преобразования URL в HTML гиперссылку с преобразованием 
спецсимволов и пробелов, а так же добавления _session id_ к URL. 
Такое поведение аналогично `java.net.URLEncoder.encode()`, но с добавлением дополнительного параметра `jsessionid` в конец URL.

Метод `HttpServletResponse.encodeRedirectURL()` преобразует URL для последующего использования в методе `sendRedirect()`. 

Таким образом для HTML гиперссылок при _URL rewriting_ необходимо использовать `encodeURL()`, 
а для URL при перенаправлении - `encodeRedirectUrl()`.

[к оглавлению](#Servlet)

## 42. Какие различные методы управления сессией в сервлетах вы знаете?

__Сессия__ - это сеанс связи между клиентом и сервером, устанавливаемый на определенное время. 
Сеанс устанавливается непосредственно между клиентом и веб-сервером в момент получения первого запроса к веб-приложению. 
Каждый клиент устанавливает с сервером свой собственный сеанс, который сохраняется до окончания работы с приложением.

Сессии используются для обеспечения хранения данных во время нескольких запросов Web-страницы или на обработку информации, 
введенной в пользовательскую форму в результате нескольких HTTP-соединений (например, клиент совершает несколько покупок 
в интернет-магазине; студент отвечает на несколько тестов в системе дистанционного обучения). 

Сессия может содержать в себе множество запросов и ответов клиент-сервер.
Т.к. HTTP и веб сервер не запоминают состояния (stateless), то единственным способом поддерживать 
сессию является пересылка уникальной информации (session id) в каждом запросе и ответе между клиентом и сервером.

Существует несколько способов управления сессией (обеспечения ее уникального идентификатора) в сервлетах:

+ __User Authentication__ – Предоставление учетных данных самим пользователем в момент аутентификации. 
Переданная таким образом информация в дальнейшем используется для поддержания сеанса. 
Это метод не будет работать, если пользователь вошёл в систему одновременно из нескольких мест.
+ __HTML Hidden Field__ – Присвоение уникального значения скрытому полю HTML страницы, 
в момент когда пользователь начинает сеанс. Этот метод не может быть использован со ссылками, потому что нуждается в 
подтверждении формы со скрытым полем каждый раз во время формирования запроса. 
Кроме того, это не безопасно, т.к. существует возможность простой подмены такого идентификатора.
+ __URL Rewriting__ – Добавление идентификатора сеанса как параметра URL. Достаточно утомительная операция, 
потому что требует постоянного отслеживания этого идентификатора при каждом запросе или ответе.
+ __Cookies__ – Использование небольших фрагментов данных, отправленных web-сервером и хранимых на устройстве пользователя. 
Данный метод не будет работать, если клиент отключает использование cookies.
+ __Session Management API__ – Использование специального API для отслеживания сеанса, построенный на основе 
и на методах описанных выше и который решает частные проблемы перечисленных способов:
    + Чаще всего недостаточно просто отслеживать сессию, необходимо ещё и сохранять какие-либо дополнительные данные о ней, 
    которые могут потребоваться при обработке последующих запросов. Осуществление такого поведения требует много дополнительных усилий.
    + Все вышеперечисленные методы не являются универсальными: для каждого из них можно подобрать конкретный сценарий, 
    при котором они не будут работать.

Java Servlet Session Management Tutorial with Examples of Cookies, HttpSession and URL Rewriting:
http://www.journaldev.com/1907/java-servlet-session-management-tutorial-with-examples-of-cookies-httpsession-and-url-rewriting

[к оглавлению](#Servlet)

## 43. Что означает URL Rewriting?

Для управления сессией в сервлетах мы можем использовать `HTTPSession`, но он работает с _cookies_, а их иногда отключают. 
Для этого случая в сервлетах предусмотрена возможность `URL Rewriting`.

__URL Rewriting__ - специальная перезапись (перекодирование) оригинального URL.  
Данный механизм может использоваться для управления сессией в сервлетах, когда _cookies_ отключены, т.е. 
этот метод является как бы запасным.

Применяя метод `HttpServletResponse` `encodeURL()` мы можем закодировать URL. Если необходим редирект к другому ресурсу, 
то для предоставления информации о сессии применяется метод `encodeRedirectURL()`.

[к оглавлению](#Servlet)

## 44. Как применяются Cookies в сервлетах?

__Сookies («куки»)__ — небольшой фрагмент данных, отправленный web-сервером и хранимый на устройстве пользователя. 
Всякий раз при попытке открыть страницу сайта, web-клиент пересылает соответствующие этому сайту cookies web-серверу 
в составе HTTP-запроса. 

Применяется для сохранения данных на стороне пользователя и на практике обычно используется для:
+ аутентификации пользователя;
+ хранения персональных предпочтений и настроек пользователя;
+ отслеживания состояния сеанса доступа пользователя;
+ ведения разнообразной статистики.

Cookies (куки) используются в клиент-серверном взаимодействии и они не являются чем-то конкретным к Java. 
Servlet API предоставляет поддержку cookies через класс `javax.servlet.http.Cookie` `implements Serializable, Cloneable`:

+ Для получения массива cookies из запроса необходимо воспользоваться методом `HttpServletRequest.getCookies()`. 
Методов для добавления cookies в запрос `HttpServletRequest` не предусмотрено.
+ Для добавления cookie в ответ используется `HttpServletResponse.addCookie(Cookie c)`. 
Метода получения cookies в `HttpServletResponse` отсутствует.

http://www.journaldev.com/1956/servlet-cookie-example-tutorial

[к оглавлению](#Servlet)

## 45. Как уведомить объект в сессии, что сессия недействительна или закончилась?

Чтобы быть уверенным в том, что объект будет оповещён о прекращении сессии, нужно реализовать интерфейс 
`javax.servlet.http.HttpSessionBindingListener`. 

Два метода этого интерфейса: `valueBound()` и `valueUnbound()` используются для реализации логики при добавлении 
объекта в качестве атрибута к сессии и при уничтожении сессии соответственно.

http://www.journaldev.com/1945/servlet-listener-example-servletcontextlistener-httpsessionlistener-and-servletrequestlistener

[к оглавлению](#Servlet)

## 46. Какой существует эффективный способ удостоверится, что все сервлеты доступны только для пользователя с валидной сессией?

Сервлет фильтры используются для перехвата всех запросов между контейнером сервлетов и сервлетом. 
Поэтому логично использовать соответствующий фильтр для проверки необходимой информации (например валидности сессии) в запросе.

[к оглавлению](#Servlet)

## 47. Как мы можем обеспечить transport layer security для нашего веб приложения?

Для обеспечения _transport layer security_ необходимо настроить поддержку SSL для вашего сервлет контейнера. 
Как это сделать описано в мануалах для конкретной реализации сервлет-контейнера.

SSL (англ. Secure Sockets Layer — уровень защищённых сокетов) — семейство криптографических протоколов для установки 
шифрованного соединения между двумя сторонами, желающими обмениваться данными. 

https://javadev.ru/https/ssl-basics/

[к оглавлению](#Servlet)

## 48. Как организовать подключение к базе данных и обеспечить логирование log4j в сервлете?

При работе с большим количеством подключений к базе данных рекомендуется инициализировать их в _servlet context listener_, 
а также установить в качестве атрибута контекста для возможности использования другими сервлетами. 

Логирование Log4j подключается к сервлету с помощью _property_-файла или XML-конфигурации, 
а далее эта информация используется при конфигурировании соответствующего _context listener_.

Servlet Example in Java with Database Connection and Log4j integration
http://www.journaldev.com/1997/servlet-example-in-java-with-database-connection-and-log4j-integration

[к оглавлению](#Servlet)

## 49. Какие важные особенности существуют в Servlet 3?

+ __Servlet Annotations__. До Servlet 3 весь маппинг (конфигурация) содержался в `web.xml`, что приводило к ошибкам и неудобству 
при работе с большим количестве сервлетов. Примеры аннотаций: `@WebServlet`, `@WebInitParam`, `@WebFilter`, `@WebListener`.
+ __Web Fragments__. Одностраничное веб приложение может содержать множество модулей: все модули прописываются 
в `fragment.xml` в папке `META-INF\`. Это позволяет разделять веб приложение на отдельные модули, 
собранные как JAR-файлы в отдельной `lib\` директории.
+ __Динамическое добавление веб компонентов__. Появилась возможность программно добавлять фильтры и слушатели, 
используя `ServletContext` объект. Для этого применяются методы `addServlet()`, `addFilter()`, `addListener()`. 
Это помогает построить динамическую систему, в которой необходимый объект будет вызван только по необходимости.
+ __Асинхронное выполнение__. Поддержка асинхронной обработки позволяет передать выполнение запроса в другой поток 
без удержания всего сервера занятым.

http://www.journaldev.com/2008/async-servlet-feature-of-servlet-3

[к оглавлению](#Servlet)

## 50. Каковы различные способы аутентификации сервлета?

Спецификация сервлетов определяет четыре типа аутентификации (проверки подлинности):

+ __HTTP Basic Authentication__ - `BASIC`. При доступе к закрытым ресурсам появится окно, которое попросит ввести 
данные для аутентификации.
+ __Form Based Login__ - `FORM`. Используется собственная html форма:
+ __HTTP Digest Authentication__ - `DIGEST`. Цифровая аутентификация с шифрованием.
+ __HTTPS Authentication__ - `CLIENT-CERT`. Аутентификация с помощью клиентского сертификата.

```xml
<login-config>
    <auth-method>FORM</auth-method>
    <form-login-config>
        <form-login-page>/login.html</form-login-page>
        <form-error-page>/error.html</form-error-page>
    </form-login-config>
</login-config>
```

[к оглавлению](#Servlet)

## 51. Написать сервлет, реализующий загрузку файла на сервер?

Servlet Upload File and Download File Example
http://www.journaldev.com/1964/servlet-upload-file-and-download-file-example

[к оглавлению](#Servlet)


## Источники:

Java Servlet Specification 4.0 https://javaee.github.io/servlet-spec/downloads/servlet-4.0/servlet-4_0_FINAL.pdf

Java Servlet Technology https://docs.oracle.com/javaee/7/tutorial/servlets.htm#BNAFD

https://docs.oracle.com/javaee/7/JEETT.pdf

https://docs.oracle.com/javaee/7/api/javax/servlet/Servlet.html

Java промышленное программирование. 2007 И.Н. Блинов, В.С. Романчик. 
- Глава 17. Введение в сервлеты и JSP (стр. 414)
- Глава 18. Сервлеты (стр. 426)
- Глава 19. Java Server Page (стр. 446)

Java методы программирования. 2013 И.Н. Блинов, В.С. Романчик. 
- Глава 15. Сервлеты (стр. 456)
- Глава 16. Java Server Page (стр. 485)

Java сервлеты и JSP. Сборник рецептов - Брюс У. Перри